import Ol from 'openlayers'
const ol = Ol;
export default class Common {
    constructor({
        // 这里的vm是ol-map的vue实例
        vm,
        target
    }) {
        this.vm = vm
        const layers = this.getLayersForInit();
        const overlays = this.getOverlaysForInit();
        const controls = this.getControlsForInit();
        const options = {
            mapId: this.getMapId(),
            target,
            layers,
            overlays,
            controls,
            // controls: null,
        };
        vm.map = new ol.Map(options);
        this.initEvents();
    }
    getOverlaysForInit() {
        return []
    }
    getControlsForInit() {
        return []
    }
    getMapId() {
        return this.vm.value;
    }
    initEvents() {
        return;
    }
    getLayersOfTianditu(refData) {
        return [new Ol.layer.Tile({
            layerId: 'tainditu_traffic',
            refData,
            source: new Ol.source.XYZ({
                url: 'http://t2.tianditu.gov.cn/DataServer?T=vec_w&x={x}&y={y}&l={z}&tk=76620c5b63143f80f875dffb556b57ef'
            })
        }), new Ol.layer.Tile({
            layerId: 'tainditu_traffic_info',
            refData,
            source: new Ol.source.XYZ({
                url: 'http://t0.tianditu.com/DataServer?T=cva_w&x={x}&y={y}&l={z}&tk=76620c5b63143f80f875dffb556b57ef' // 天地图_地名
            })
        })]
    }
    getLayersOfBaseForInit(refData) {
        const {
            baseLayersInfoSources,
            baseLayersInfoIndex
        } = window.gloable;
        const baseLayersInfo = baseLayersInfoSources[baseLayersInfoIndex]
        if (baseLayersInfo) {
            return baseLayersInfo.map(({
                layerId,
                type,
                visible,
                url
            }) => {
                if (type == 'xyz') {
                    return new Ol.layer.Tile({
                        layerId,
                        refData,
                        visible,
                        source: new Ol.source.XYZ({
                            url
                        })
                    })
                } else if (type == 'geojson') {
                    return this.getLayerVectorForInit({
                        layerId,
                        refData,
                        source: new ol.source.Vector({
                            projection: 'EPSG:4326',
                            url,
                            format: new ol.format.GeoJSON()
                        }),
                        visible,
                        style(f) {
                            // console.log('f.getProperties()', f.getProperties());
                            return new ol.style.Style({
                                fill: new ol.style.Fill({ //矢量图层填充颜色，以及透明度
                                    color: 'rgba(255, 255, 255, 0)'
                                }),
                                stroke: new ol.style.Stroke({ //边界样式
                                    color: '#ffa09a',
                                    width: 3
                                })
                            })
                        }
                    })
                }
            })
            // })), ...this.getLayersOfgxborderForInit()]
        } else {
            return []
        }
    }
    setCollection({
        key,
        data
    }) {
        const {
            vm: {
                collectionMap
            }
        } = this;
        const collection = collectionMap[key];
        if (collection) {
            collection.clear();
            collection.extend(data);
        } else {
            console.error(`collection key:${key} not found`);
        }
    }
    getLayersOfgxborderForInit() {
        return [this.getLayerVectorForInit({
            layerId: "gxborder",
            source: {
                name: "gxborder"
            },
            visible: false,
            style(f) {
                // console.log('f.getProperties()', f.getProperties());
                return new ol.style.Style({
                    fill: new ol.style.Fill({ //矢量图层填充颜色，以及透明度
                        color: 'rgba(255, 255, 255, 0)'
                    }),
                    stroke: new ol.style.Stroke({ //边界样式
                        color: '#ffa09a',
                        width: 3
                    })
                })
            }
        })]
    }
    getLayersOfMap() {
        const {
            vm: {
                map
            }
        } = this;
        return map.getLayers().getArray();
    }
    getLayerVectorForInit(layerInfo) {
        const vm = this.vm;
        const {
            sourceMap,
            collectionMap
        } = vm;
        let thisLayer;
        let source;
        if (typeof(layerInfo.source) === "string") {
            source = sourceMap[layerInfo.source];
        } else if (layerInfo.source.name) {
            const sourceId = layerInfo.source.name;
            if (!sourceMap[sourceId]) {
                const collectionId = layerInfo.collection || sourceId;
                if (!collectionMap[collectionId]) {
                    collectionMap[collectionId] = new ol.Collection();
                }
                const features = collectionMap[collectionId];
                // console.log('features', features);
                const thisSource = new Ol.source.Vector({
                    features
                })
                sourceMap[sourceId] = thisSource;
            }
            source = sourceMap[sourceId];
        } else {
            source = layerInfo.source
        }
        thisLayer = new Ol.layer.Vector({
            source,
            layerId: layerInfo.layerId,
            refData: layerInfo,
            visible: layerInfo.visible !== false,
            style: layerInfo.style
        });
        // thisLayer.set('layerId', )
        // thisLayer.set('refData', layerInfo)
        // thisLayer.set('visible', )
        return thisLayer;
    }
    controlDefaults(controlInfo) {
        if (controlInfo.extend && controlInfo.extend.map) {
            const arrExtend = controlInfo.extend.map(extend => {
                if (typeof(extend) === "string") {
                    switch (extend) {
                        case "FullScreen":
                            return new Ol.control.FullScreen()
                            break;
                        default:
                            return null
                    }
                }
            })
            return Ol.control.defaults().extend(arrExtend).getArray();
        } else {
            return Ol.control.defaults().getArray();
        }
    }
    controlAuto({
        types
    }) {
        if (types && types.map) {
            return types.map(item => {
                let info
                if (typeof(item) === 'string') {
                    info = {
                        type: item
                    }
                } else {
                    info = {
                        ...item
                    }
                }
                const {
                    type
                } = info;
                delete info.type;
                const factory = ol.control[type];
                if (factory) {
                    return new factory(info)
                }
            })
        }
    }
    getControlsOfMousePosition({
        undefinedHTML,
        className,
        coordinateFormatString
    }) {
        return new Ol.control.MousePosition({
            undefinedHTML: undefinedHTML ? undefinedHTML : '不在范围内',
            projection: 'EPSG:4326',
            // projection: 'EPSG:3857',
            className,
            coordinateFormat: function(coordinate) {
                return Ol.coordinate.format(coordinate, coordinateFormatString ? coordinateFormatString : '{x}&nbsp,&nbsp{y}', 4);
            }
        })
    }
    getInteractionDefaults(interactionInfo) {
        return Ol.interaction.defaults().getArray();
    }
    interactionSelect({
        features
    }) {
        const vm = this.vm;
        var select = new Ol.interaction.Select();
        if (typeof(features) === "string") {
            var selectedFeatures = select.getFeatures();
            vm.featureMap[features] = selectedFeatures;
        }
        return select;
    }
    interactionDragBox({
        handles
    }) {
        const vm = this.vm;
        var dragBox = new Ol.interaction.DragBox({
            condition: Ol.events.condition.platformModifierKeyOnly
        });
        if (handles && handles.map) {
            handles
                .map(vm.mapBundleFuncionByBundlePathInfo)
                .filter(item => item)
                .forEach(bundle => {
                    bundle({
                        dragBox
                    })
                });
        }
        return dragBox;
    }
    //获取地图的投影代码
    getProjectionCode() {
        return this.vm.map.getView().getProjection().getCode() || "EPSG:3857";
    }
    transformToLonLat([lon, lat], projection) {
        return ol.proj.transform([lon - 0, lat - 0], this.getProjectionCode(), projection || "EPSG:4326");
    }
    transformFromLonLat([lon, lat], projection) {
        return ol.proj.transform([lon - 0, lat - 0], projection || "EPSG:4326", this.getProjectionCode());
    }
    //解析geojson数据
    readFeaturesGeojson(geojson) {
        return (new ol.format.GeoJSON()).readFeatures(geojson, {
            featureProjection: this.getProjectionCode()
        })
    }
    transformViewInfo(info) {
        const {
            projection = "EPSG:4326",
                lon,
                lat
        } = info;
        return {
            ...info,
            projection: "EPSG:3857",
            center: this.transformFromLonLat([lon, lat], projection)
        }
    }
    setView(info) {
        const {
            vm: {
                map
            }
        } = this;
        map.setView(new ol.View(this.transformViewInfo(info)));
    }
    updateView(info) {
        const {
            vm: {
                map
            }
        } = this;
        const view = map.getView();
        if (view) {
            view.animate({
                zoom: Math.min(view.getZoom(), info.zoom || view.getZoom()) - 1
            }, this.transformViewInfo(info));
        } else {
            this.setView(info);
        }
    }
    trackMapClick() {
        const {
            vm,
            vm: {
                map
            }
        } = this;
        map.on('click', (e) => {
            console.log('e.coordinate', e.coordinate, this.transformToLonLat(e.coordinate));
            var pixel = map.getEventPixel(e.originalEvent);
            var hit = map.hasFeatureAtPixel(pixel);
            if (hit) {
                const features = [];
                map.forEachFeatureAtPixel(pixel, function(feature, layer) {
                    features.push({
                        feature,
                        layer,
                        properties: feature.getProperties()
                    })
                });
                vm.$emit('click-on-features', {
                    features,
                    e
                });
            }
        });
    }
    trackPointer() {
        const {
            vm,
            vm: {
                map
            }
        } = this;
        map.on('pointermove', function(e) {
            var pixel = map.getEventPixel(e.originalEvent);
            var hit = map.hasFeatureAtPixel(pixel);
            if (hit) {
                const features = [];
                map.forEachFeatureAtPixel(pixel, function(feature, layer) {
                    features.push({
                        feature,
                        layer,
                        properties: feature.getProperties()
                    })
                });
                vm.$emit('pointer-on-features', {
                    features,
                    e
                });
            } else {
                vm.$emit('pointer-off-feature')
            }
        })
    }
}
